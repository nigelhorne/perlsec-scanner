#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;
use File::Find;
use JSON;
use lib './lib';
use RegexCheck qw(check_regex_danger);
use VersionCheck qw(check_module_versions load_allowed_versions);
use PatternCheck qw(check_static_patterns);
use Cwd 'realpath';

# CLI Options
my ($dir, $output, $format, $help);
my $verbose = 0;
GetOptions(
    'input|i=s'   => \$dir,
    'output|o=s'  => \$output,
    'format|f=s'  => \$format,
    'verbose|v!'  => \$verbose,
    'help|h'      => \$help,
);

# Defaults
$dir    ||= '.';
$output ||= 'findings.json';
$format ||= 'json';

if ($help) {
    print <<"USAGE";
Usage: perlsec-scan --input <dir> --output <file> --format <html|json|sarif|txt>
Scans Perl files for insecure patterns, risky regexes, and outdated modules.
USAGE
    exit 0;
}

$dir = realpath($dir) or die "Invalid input path: $dir";

# Load version allowlist
my %allowed = load_allowed_versions('allowed_modules.txt');

# Scan files
my @suspect_lines;
find(sub {
    return unless /\.pl$/i;
    my $file = $File::Find::name;
    print "[+] Scanning $file\n" if $verbose;
    open my $fh, '<', $file or warn "Can't open $file: $!" and return;
    while (<$fh>) {
        my $line = $_;
        my $ln   = $.;
        check_static_patterns($line, $file, $ln, \@suspect_lines);
        check_regex_danger($line, $file, $ln, \@suspect_lines);
        check_module_versions($line, $file, $ln, \@suspect_lines, \%allowed);
    }
    close $fh;
}, $dir);

if ($verbose && @suspect_lines) {
    print "[!] Found ", scalar @suspect_lines, " issues\n";
} elsif ($verbose) {
    print "[âœ“] No issues found in $dir\n";
}

# Output
if ($format eq 'json') {
	open my $out, '>', $output or die "Can't write to $output: $!";
	my @results;
	for my $entry (@suspect_lines) {
		my ($file, $line_no, $desc) = @$entry;
		push @results, {
			file    => $file,
			line    => $line_no,
			message => $desc,
		};
	}
	print $out encode_json(\@results);

	close $out;
	print "Results saved to $output\n" if($verbose);
} elsif ($format eq 'txt') {
    open my $out, '>', $output or die "Can't write to $output: $!";
    for (@suspect_lines) {
        my ($file, $line, $msg) = @$_;
        print $out "$file [$line]: $msg\n";
    }
    close $out;
    print "Text report saved to $output\n" if($verbose);
} elsif ($format eq 'sarif') {
    open my $out, '>', $output or die "Can't write to $output: $!";

	my $schema = 'https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0.json';

	my @results_sarif = map {
	    +{
		ruleId   => 'perlsec',
		message  => { text => $_->[2] },
		locations => [{
		    physicalLocation => {
			artifactLocation => {
			    uri       => $_->[0],
			    uriBaseId => '%SRCROOT%',
			},
			region => {
			    startLine => $_->[1],
			}
		    }
		}]
	    }
	} @suspect_lines;

	my %sarif = (
	    version => '2.1.0',
	    '$schema' => $schema,
	    runs => [{
		tool => {
		    driver => {
			name           => 'PerlSec Scanner',
			informationUri => 'https://github.com/your-username/perlsec-scanner',
			rules => [{
			    id   => 'perlsec',
			    name => 'Perl static pattern checker',
			}]
		    }
		},
		results => \@results_sarif,
	    }]
	);


    print $out encode_json(\%sarif);
    close $out;
    print "SARIF report saved to $output\n" if $verbose;
} elsif ($format eq 'html') {
    open my $out, '>', $output or die "Can't write to $output: $!";

    my $issue_rows = join "\n", map {
        my ($file, $line, $message) = @$_;
        "<tr><td>$file</td><td>$line</td><td>$message</td></tr>"
    } @suspect_lines;

    my $count = scalar @suspect_lines;

my %grouped;
for my $entry (@suspect_lines) {
    my ($file, $line, $msg, $type) = @$entry;
    $type ||= 'Uncategorized';
    push @{ $grouped{$type} }, [$file, $line, $msg];
}

my $issue_sections = join "\n", map {
    my $type = $_;
    my $rows = join "\n", map {
        my ($f, $l, $m) = @$_;
        "<tr><td>$f</td><td>$l</td><td>$m</td></tr>"
    } @{ $grouped{$type} };

    <<"HTML"
<h2>$type</h2>
<table>
  <thead><tr><th>File</th><th>Line</th><th>Message</th></tr></thead>
  <tbody>$rows</tbody>
</table>
HTML
} sort keys %grouped;

my $summary_table = join '', map {
    my $count = scalar @{ $grouped{$_} };
    "<tr><td>$_</td><td>$count</td></tr>"
} sort keys %grouped;

$summary_table = <<"HTML";
<h2>Summary</h2>
<table>
  <thead><tr><th>Issue Type</th><th>Count</th></tr></thead>
  <tbody>$summary_table</tbody>
</table>
HTML

    print $out <<"HTML";
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PerlSec Scan Report</title>
  <style>
    body { font-family: sans-serif; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 6px; }
    th { background: #eee; }
    .summary { margin-top: 1em; font-weight: bold; }
  </style>
</head>
<body>
  <h1>PerlSec Scan Report</h1>
  <div class="summary">$count issues found</div>

  <canvas id="chart" height="100"></canvas>

  $summary_table
  $issue_sections

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const data = {
      labels: ["Security Issues"],
      datasets: [{
        label: "Findings",
        data: [$count],
        backgroundColor: ["#d9534f"]
      }]
    };
    new Chart(document.getElementById('chart'), {
      type: 'bar',
      data: data,
      options: {
        responsive: false,
        scales: { y: { beginAtZero: true } }
      }
    });
  </script>
</body>
</html>
HTML

    close $out;
    print "HTML report saved to $output\n" if $verbose;
} else {
    die "Unknown format: $format\n";
}
