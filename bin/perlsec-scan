#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;
use File::Find;
use JSON;
use lib './lib';
use RegexCheck qw(check_regex_danger);
use VersionCheck qw(check_module_versions load_allowed_versions);
use PatternCheck qw(check_static_patterns);
use Cwd 'realpath';

# CLI Options
my ($dir, $output, $format, $help);
my $verbose = 0;
GetOptions(
    'input|i=s'   => \$dir,
    'output|o=s'  => \$output,
    'format|f=s'  => \$format,
    'verbose|v!'  => \$verbose,
    'help|h'      => \$help,
);

# Defaults
$dir    ||= '.';
$output ||= 'findings.json';
$format ||= 'json';

if ($help) {
    print <<"USAGE";
Usage: perlsec-scan --input <dir> --output <file> --format <json|txt>
Scans Perl files for insecure patterns, risky regexes, and outdated modules.
USAGE
    exit 0;
}

$dir = realpath($dir) or die "Invalid input path: $dir";

# Load version allowlist
my %allowed = load_allowed_versions('allowed_modules.txt');

# Scan files
my @suspect_lines;
find(sub {
    return unless /\.pl$/i;
    my $file = $File::Find::name;
    print "[+] Scanning $file\n" if $verbose;
    open my $fh, '<', $file or warn "Can't open $file: $!" and return;
    while (<$fh>) {
        my $line = $_;
        my $ln   = $.;
        check_static_patterns($line, $file, $ln, \@suspect_lines);
        check_regex_danger($line, $file, $ln, \@suspect_lines);
        check_module_versions($line, $file, $ln, \@suspect_lines, \%allowed);
    }
    close $fh;
}, $dir);

if ($verbose && @suspect_lines) {
    print "[!] Found ", scalar @suspect_lines, " issues\n";
} elsif ($verbose) {
    print "[âœ“] No issues found in $dir\n";
}

# Output
if ($format eq 'json') {
	open my $out, '>', $output or die "Can't write to $output: $!";
	my @results;
	for my $entry (@suspect_lines) {
		my ($file, $line_no, $desc) = @$entry;
		push @results, {
			file    => $file,
			line    => $line_no,
			message => $desc,
		};
	}
	print $out encode_json(\@results);

	close $out;
	print "Results saved to $output\n" if($verbose);
} elsif ($format eq 'txt') {
    open my $out, '>', $output or die "Can't write to $output: $!";
    for (@suspect_lines) {
        my ($file, $line, $msg) = @$_;
        print $out "$file [$line]: $msg\n";
    }
    close $out;
    print "Text report saved to $output\n" if($verbose);
} elsif ($format eq 'sarif') {
    open my $out, '>', $output or die "Can't write to $output: $!";

	my $schema = 'https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0.json';

	my @results_sarif = map {
	    +{
		ruleId   => 'perlsec',
		message  => { text => $_->[2] },
		locations => [{
		    physicalLocation => {
			artifactLocation => {
			    uri       => $_->[0],
			    uriBaseId => '%SRCROOT%',
			},
			region => {
			    startLine => $_->[1],
			}
		    }
		}]
	    }
	} @suspect_lines;

	my %sarif = (
	    version => '2.1.0',
	    '$schema' => $schema,
	    runs => [{
		tool => {
		    driver => {
			name           => 'PerlSec Scanner',
			informationUri => 'https://github.com/your-username/perlsec-scanner',
			rules => [{
			    id   => 'perlsec',
			    name => 'Perl static pattern checker',
			}]
		    }
		},
		results => \@results_sarif,
	    }]
	);


    print $out encode_json(\%sarif);
    close $out;
    print "SARIF report saved to $output\n" if $verbose;
} else {
    die "Unknown format: $format\n";
}
